#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;

layout(rg32f, binding = 0) readonly uniform image2D velocity;
layout(rgba32f, binding = 1) writeonly uniform image2D densityOut;

uniform sampler2D densityIn;
uniform float dt;
uniform vec2 texelSize;
uniform float dissipation;

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(velocity);

    if (pos.x >= size.x || pos.y >= size.y) return;

    // Density lives at cell center (i+0.5, j+0.5)
    vec2 uv = (vec2(pos) + 0.5) * texelSize;

    // Interpolate velocity to cell center (MAC grid)
    // u lives at left faces, so average u[i,j] and u[i+1,j] to get u at center
    // v lives at bottom faces, so average v[i,j] and v[i,j+1] to get v at center
    // Open boundary: velocity = 0 outside domain
    float u_left = imageLoad(velocity, pos).x;
    float u_right = (pos.x < size.x - 1) ? imageLoad(velocity, pos + ivec2(1, 0)).x : 0.0;
    float v_bottom = imageLoad(velocity, pos).y;
    float v_top = (pos.y < size.y - 1) ? imageLoad(velocity, pos + ivec2(0, 1)).y : 0.0;

    vec2 vel = vec2(0.5 * (u_left + u_right), 0.5 * (v_bottom + v_top));

    // Trace back in time (velocity is in grid cells/sec, convert to UV space)
    vec2 prevUV = uv - vel * texelSize * dt;

    // Sample density at previous position
    vec4 result = texture(densityIn, prevUV);

    // Apply dissipation
    result *= dissipation;

    imageStore(densityOut, pos, result);
}
