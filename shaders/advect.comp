#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;

layout(r32f, binding = 0) writeonly uniform image2D uVelocityOut;
layout(r32f, binding = 1) writeonly uniform image2D vVelocityOut;

uniform sampler2D uVelocitySampler;
uniform sampler2D vVelocitySampler;
uniform float dt;
uniform vec2 texelSize;
uniform float dissipation;

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(uVelocityOut);

    if (pos.x >= size.x || pos.y >= size.y) return;

    // MAC grid: u[i,j] at left face (i, j+0.5), v[i,j] at bottom face (i+0.5, j)

    // === Advect u component at left face (i, j+0.5) ===
    vec2 uv_u = vec2(float(pos.x), float(pos.y) + 0.5) * texelSize;

    // u is already at left face, need to interpolate v to left face
    // v values are at bottom faces: v[i,j] at (i+0.5, j)
    // Average 4 surrounding v values to get v at (i, j+0.5)
    vec2 vSamplePos = (vec2(pos) + 0.5) * texelSize;
    float v00 = texture(vVelocitySampler, vSamplePos + vec2(-1.0, 0.0) * texelSize).r;
    float v10 = texture(vVelocitySampler, vSamplePos).r;
    float v01 = texture(vVelocitySampler, vSamplePos + vec2(-1.0, 1.0) * texelSize).r;
    float v11 = texture(vVelocitySampler, vSamplePos + vec2(0.0, 1.0) * texelSize).r;

    float u_here = texture(uVelocitySampler, uv_u).r;
    float v_at_u = 0.25 * (v00 + v10 + v01 + v11);
    vec2 vel_at_u = vec2(u_here, v_at_u);

    // Trace back and sample u
    vec2 prevUV_u = uv_u - vel_at_u * texelSize * dt;
    float new_u = texture(uVelocitySampler, prevUV_u).r;

    // === Advect v component at bottom face (i+0.5, j) ===
    vec2 uv_v = vec2(float(pos.x) + 0.5, float(pos.y)) * texelSize;

    // v is already at bottom face, need to interpolate u to bottom face
    // u values are at left faces: u[i,j] at (i, j+0.5)
    // Average 4 surrounding u values to get u at (i+0.5, j)
    vec2 uSamplePos = (vec2(pos) + 0.5) * texelSize;
    float u00 = texture(uVelocitySampler, uSamplePos + vec2(0.0, -1.0) * texelSize).r;
    float u10 = texture(uVelocitySampler, uSamplePos + vec2(1.0, -1.0) * texelSize).r;
    float u01 = texture(uVelocitySampler, uSamplePos).r;
    float u11 = texture(uVelocitySampler, uSamplePos + vec2(1.0, 0.0) * texelSize).r;

    float v_here = texture(vVelocitySampler, uv_v).r;
    float u_at_v = 0.25 * (u00 + u10 + u01 + u11);
    vec2 vel_at_v = vec2(u_at_v, v_here);

    // Trace back and sample v
    vec2 prevUV_v = uv_v - vel_at_v * texelSize * dt;
    float new_v = texture(vVelocitySampler, prevUV_v).r;

    // Apply dissipation
    new_u *= dissipation;
    new_v *= dissipation;

    imageStore(uVelocityOut, pos, vec4(new_u, 0.0, 0.0, 0.0));
    imageStore(vVelocityOut, pos, vec4(new_v, 0.0, 0.0, 0.0));
}
